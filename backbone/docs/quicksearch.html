<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"docs_scripts_fulltext-search-ui.js.html":{"id":"docs_scripts_fulltext-search-ui.js.html","title":"Source: docs/scripts/fulltext-search-ui.js","body":" Dispatchr Backbone Classes BackboneClientBackboneClientMessageBackboneServiceCmdService Source: docs/scripts/fulltext-search-ui.js window.SearcherDisplay = (function($) { /** * This class provides support for displaying quick search text results to users. */ function SearcherDisplay() { } SearcherDisplay.prototype.init = function() { this._displayQuickSearch(); }; /** * This method creates the quick text search entry in navigation menu and wires all required events. */ SearcherDisplay.prototype._displayQuickSearch = function() { var quickSearch = $(document.createElement(&quot;iframe&quot;)), body = $(&quot;body&quot;), self = this; quickSearch.attr(&quot;src&quot;, &quot;quicksearch.html&quot;); quickSearch.css(&quot;width&quot;, &quot;0px&quot;); quickSearch.css(&quot;height&quot;, &quot;0px&quot;); body.append(quickSearch); $(window).on(&quot;message&quot;, function(msg) { var msgData = msg.originalEvent.data; if (msgData.msgid != &quot;docstrap.quicksearch.done&quot;) { return; } var results = msgData.results || []; self._displaySearchResults(results); }); function startSearch() { var searchTerms = $('#search-input').prop(&quot;value&quot;); if (searchTerms) { quickSearch[0].contentWindow.postMessage({ &quot;searchTerms&quot;: searchTerms, &quot;msgid&quot;: &quot;docstrap.quicksearch.start&quot; }, &quot;*&quot;); } } $('#search-input').on('keyup', function(evt) { if (evt.keyCode != 13) { return; } startSearch(); return false; }); $('#search-submit').on('click', function() { startSearch(); return false; }); }; /** * This method displays the quick text search results in a modal dialog. */ SearcherDisplay.prototype._displaySearchResults = function(results) { var resultsHolder = $($(&quot;#searchResults&quot;).find(&quot;.modal-body&quot;)), fragment = document.createDocumentFragment(), resultsList = document.createElement(&quot;ul&quot;); resultsHolder.empty(); for (var idx = 0; idx &lt; results.length; idx++) { var result = results[idx], item = document.createElement(&quot;li&quot;), link = document.createElement(&quot;a&quot;); link.href = result.id; link.innerHTML = result.title; item.appendChild(link) resultsList.appendChild(item); } fragment.appendChild(resultsList); resultsHolder.append(fragment); $(&quot;#searchResults&quot;).modal({&quot;show&quot;: true}); }; return new SearcherDisplay(); })($); × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-11-17T16:42:08-08:00 using the DocStrap template. "},"client_client.js.html":{"id":"client_client.js.html","title":"Source: client/client.js","body":" Dispatchr Backbone Classes BackboneClientBackboneClientMessageBackboneServiceCmdService Source: client/client.js /** * @fileoverview This is is a generic broker client api for javascript * * */ var zmq = require('zmq'); //https://github.com/JustinTulloss/zeromq.node/blob/master/README.md var BPromise = require('bluebird'); var Message = require('./mdc_protocol'); const DEFAULT_HOST = '127.0.0.1'; const DEFAULT_PORT = '5555'; /** * @constructor * @description test {@link README.md readme} * @param {String} host host to connect to backbone * @param {String} port port to connect to backbone */ function BackboneClient(host, port) { this.host = host || DEFAULT_HOST; this.port = port || DEFAULT_PORT; this._socket = zmq.socket('req'); } /** * @function getEndpoint * @description get endpoint url * @memberof BackboneClient * @instance * @returns {String} The url of the endpoint */ BackboneClient.prototype.getEndpoint = function(){ return `tcp://${this.host}:${this.port}`; }; /** * Connect to the BackboneClient. */ BackboneClient.prototype.connect = function() { this._socket.connect(this.getEndpoint()); return new BPromise((resolve, reject) =&gt; { //Events here: https://github.com/JustinTulloss/zeromq.node/blob/master/README.md this._socket.on('connect', () =&gt; { resolve(this); }); this._socket.on('bind_error', () =&gt; { reject(new Error(&quot;ZMQ_EVENT_BIND_FAILED&quot;)); }); }); }; /** * Disconnect this conection to the BackboneClient. */ BackboneClient.prototype.disconnect = function() { this._socket.disconnect(this.getEndpoint()); return new BPromise((resolve, reject) =&gt; { //Events here: https://github.com/JustinTulloss/zeromq.node/blob/master/README.md this._socket.on('disconnect', () =&gt; { resolve(this); }); this._socket.on('bind_error', () =&gt; { reject(new Error(&quot;ZMQ_EVENT_BIND_FAILED&quot;)); }); }); }; /** * @param {String} service name of service to send message to * @param {String|Array} port port to connect to backbone * @param {Number} timeout amount of time in milliseconds to wait for response before giving up * * @return {Promise} response promise */ BackboneClient.prototype.send = function(service, message, timeout) { message = message || []; timeout = timeout || 3000; if(!Array.isArray(message)) { message = [message]; } return new BPromise((resolve, reject) =&gt; { var timer = null; //setup timeout if needed if(timeout) { timeout = parseInt(timeout); if(timeout &gt; 0) { timer = setTimeout(() =&gt; { timer = -1; //timed out reject(&quot;Request Timeout&quot;); },timeout); } } //send request mdp_request(this._socket, service, message, timeout, function(reply) { // console.log(&quot;GOT REPLY&quot;, service, message, reply); if(timer !== -1) { //not timed out resolve(reply); } if(timer) { clearTimeout(timer); } }); }); }; /** * @function mdp_request * @private * @description MDP request. * This function sends a request to the given service and * waits for a reply. * * If timeout is set and no reply received in the given time * the function will return `None`. * * @param {Object} socket zmq REQ socket to use. zmq.Socket * @param {String} service service id to send the msg to. * @param {String} msg list of message parts to send. * @param {Number} timeout time to wait for answer in milliseconds. * @param {Function} cb callback */ function mdp_request(socket, service, msg, timeout, cb) { if(!timeout || timeout &lt; 0.0) { timeout = null; } var to_send = new Message(service, msg); socket.send(to_send.serialize()); socket.on('message', function() {//prot_ver, service) { var reply = to_send.parseReply(arguments); cb(reply); }); } module.exports = BackboneClient; × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-11-17T16:42:08-08:00 using the DocStrap template. "},"client_mdc_protocol.js.html":{"id":"client_mdc_protocol.js.html","title":"Source: client/mdc_protocol.js","body":" Dispatchr Backbone Classes BackboneClientBackboneClientMessageBackboneServiceCmdService Source: client/mdc_protocol.js &quot;use strict&quot;; /** * @fileoverview MajorDomo Client Protocol this helper class serializes client messages and replys * */ var _ = require(&quot;underscore&quot;); const PROTOCOL_VERSION = &quot;MDPC01&quot;; //Major Domo Protocol /** * @class BackboneClientMessage * @param {String} service Name of the service * @param {String|Array} message message to be serialized */ class BackboneClientMessage { constructor(service, message){ this.protocol = PROTOCOL_VERSION; this.service = service; this.message = message; } /** * @function serialize * @memberof BackboneClientMessage * @instance * @description serializes the message to be sent to the Major Domo Broker * @returns {Array} message array to be sent */ serialize() { var raw_message = this.message; if(!Array.isArray(raw_message)) { raw_message = [raw_message]; } raw_message = [this.protocol, this.service].concat(raw_message); return raw_message; } /** * @function parseReply * @description Parses reply to this message * @memberof BackboneClientMessage * @instance * @param {Array} raw_reply reply gotten from zmq socket * @param {Object} options * @param {Object} options.simply_short_reply If reply has only one item return only the first item. * @returns {Array} reply message with protocol info stripped out */ parseReply(raw_reply, options){ //configure options options = options || {}; options.simply_short_reply = options.simply_short_reply || true; //parse reply var ret = _.map(raw_reply, msgbuf =&gt; msgbuf.toString()); this.reply = {}; this.reply.protocol = ret.shift(); this.reply.service = ret.shift(); this.reply.message = ret; if(options.simply_short_reply &amp;&amp; this.reply.message.length === 1) { this.reply.message = ret[0]; } return this.reply.message; } /** * @function parseResponse * @description alias to parseReply * @memberof BackboneClientMessage * @instance */ parseResponse(raw_reply, options){ return this.parseReply(raw_reply, options); } /** * @function getReply * @description get the reply message * @memberof BackboneClientMessage * @instance * @returns {Array|String} the reply sent to this message */ getReply(){ return this.reply.message; } } module.exports = BackboneClientMessage; × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-11-17T16:42:08-08:00 using the DocStrap template. "},"service_service.js.html":{"id":"service_service.js.html","title":"Source: service/service.js","body":" Dispatchr Backbone Classes BackboneClientBackboneClientMessageBackboneServiceCmdService Source: service/service.js &quot;use strict&quot;; /** * @fileoverview This is is a generic broker woker api for javascript */ var zmq = require('zmq'); //https://github.com/JustinTulloss/zeromq.node/blob/master/README.md var _ = require('underscore'); const HB_INTERVAL = 1000; // in milliseconds const HB_LIVENESS = 3; // HBs to miss before connection counts as dead const PROTO_VERSION = 'MDPW01'; //MajorDomo Protocol Woker 1 const MESSAGE_READY = '\\x01'; const MESSAGE_REQUEST = '\\x02'; const MESSAGE_REPLY = '\\x03'; const MESSAGE_HEARTBEAT = '\\x04'; const MESSAGE_DISCONNECT = '\\x05'; /** * This function is called whenever the service recieves a message. * @callback BackboneService~on_request * @param {String|Array} message Message Array * @param {BackboneService~reply} reply Reply callback */ /** * This callback is sent with the message as a way to reply to the message * @callback BackboneService~reply * @param {String|Array} message Message Array to be sent as reply to request. */ class BackboneService { /** * @constructor * @param {String} service name of the service * @param {BackboneService~on_request} on_request - The callback that handles the response. * @param {Object} options * @param {String} options.host host to connect to backbone * @param {String} options.port port to connect to backbone */ constructor(service, on_request, options) { options = options || {}; this.host = options.host || '127.0.0.1'; this.port = options.port || &quot;5555&quot;; this.service = service; this.on_request = on_request; this.stream = null; this._tmo = null; this.need_handshake = true; this.ticker = null; this._delayed_cb = null; var self = this; var endpoint = this.getEndpoint(); this._socket = zmq.socket('dealer'); this._socket.monitor(500, 0); this._socket.on('message', function(){ var args = _.map(arguments, msgbuf =&gt; msgbuf); self._on_message(args); }); this._socket.on('connect', function(){ console.log(&quot;Connected: &quot;, endpoint); }); this._socket.on('disconnect', function(){ console.log(&quot;Disconnected: &quot;, endpoint); }); } getEndpoint() { return `tcp://${this.host}:${this.port}`; } /** * @function * @memberof BackboneService * @instance * @description Connect service to backbon */ connect(){ var self = this; var endpoint = this.getEndpoint(); console.log(&quot;Registering Service&quot;, this.service); this._socket.connect(endpoint); this._send_ready(); this.ticker = setInterval(function() { self._tick(); }, HB_INTERVAL); } _send_ready() { var ready_msg = [ '', PROTO_VERSION, MESSAGE_READY, this.service ]; this._socket.send(ready_msg); this.curr_liveness = HB_LIVENESS; } _tick(){ var self = this; this.curr_liveness -= 1; // console.log('%.3f tick - %d' % (time.time(), self.curr_liveness); this.send_heartbeat(); if(this.curr_liveness &lt; 0){ console.log('Connection Lost'); // ouch, connection seems to be dead this.shutdown(); // try to recreate it this._delayed_cb = setTimeout(function() { self.connect(); }, 5000); } } send_heartbeat(){ var msg = [ '', PROTO_VERSION, '\\x04' ]; this._socket.send(msg); } shutdown() { if(this.ticker){ clearInterval(this.ticker); this.ticker = null; if(this.stream) { this._socket.close(); this.timed_out = false; this.need_handshake = true; this.connected = true; } } } reply(envelope, msg){ // if self.need_handshake: // raise ConnectionNotReadyError() // prepare full message var to_send = envelope; if(Array.isArray(msg)) { to_send.push.apply(to_send, msg); } else { to_send.push(msg); } console.log(&quot;REPLY&quot;, envelope, msg); this._socket.send(to_send); } _on_message(msg) { var self = this; // 1st part is empty msg.shift(); // 2nd part is protocol version // TODO: version check var protocol = msg.shift(); if(protocol.toString() !== PROTO_VERSION) { console.error(&quot;PROTCOL VERSION MISSMATCH&quot;, protocol, PROTO_VERSION); } else { // 3rd part is message type var msg_type = msg.shift().toString(); // XXX: hardcoded message types! // any message resets the liveness counter this.need_handshake = false; this.curr_liveness = HB_LIVENESS; if(msg_type === MESSAGE_DISCONNECT){ // disconnect this.curr_liveness = 0; // reconnect will be triggered by hb timer } else if(msg_type === MESSAGE_REQUEST){// # request // remaining parts are the user message var split = split_address(msg); var envelope = split[0]; msg = split[1]; envelope.push(''); envelope = [ '', PROTO_VERSION, MESSAGE_REPLY].concat(envelope); // REPLY msg = _.each(msg, item =&gt; item.toString()); this.on_request(msg, function(reply_msg){ self.reply(envelope, reply_msg); }); } else if(msg_type !== MESSAGE_HEARTBEAT) { console.error(&quot;Unknown Message Type&quot;, msg_type); } } } } function split_address(msg) { var ret_ids = []; for(var i = 0; i &lt; msg.length; i++) { var p = msg[i]; if (p.length !== 0) { ret_ids.push(p); } else { break; } } return [ret_ids, msg.slice(i+1)]; } module.exports = BackboneService; × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-11-17T16:42:08-08:00 using the DocStrap template. "},"service_cmd.js.html":{"id":"service_cmd.js.html","title":"Source: service/cmd.js","body":" Dispatchr Backbone Classes BackboneClientBackboneClientMessageBackboneServiceCmdService Source: service/cmd.js &quot;use strict&quot;; /** * @fileoverview Service that takes a command line and arguments and turns it into a service * @author &lt;gabe@dispatchr.co&gt; (Gabriel Littman) */ var Service = require('./service'); var exec = require('child_process').exec; class CmdService extends Service { /** * @constructor * @param {String} service name of the service * @param {String} cmd name of the programe to run * @param {String} host host name or ip of broker * @param {String} port port to for service to connect to * @param {Array} options list or command line options to add to command */ constructor(service, cmd, host, port, options) { console.log(&quot;CmdService&quot;, service, host, port, cmd, options); super(service, function(msg, reply){ var full_cmd = options.concat(msg); full_cmd.unshift(cmd); full_cmd = full_cmd.join(' '); console.log(&quot;COMMAND&quot;, full_cmd); exec(full_cmd, function(error, stdout, stderr) { if(error) { reply([&quot;Error&quot;, error]); console.error(&quot;error&quot;, error); console.error(`stderr: ${stderr}`); } else { reply(stdout); } }); }, {host: host, port: port}); } } function service(name, cmd, args, opts){ // console.log(&quot;service&quot;, name, cmd, args, opts); var host = opts.host; var port = opts.port; delete opts.host; delete opts.port; host = host || &quot;127.0.0.1&quot;; port = port || &quot;5555&quot;; for(var key in opts) { if(opts.hasOwnProperty(key)) { if(key.length === 1) { args.push('-'+key); } else { args.push('--'+key); } var val = opts[key]; if(val !== true &amp;&amp; val !== false) { args.push(val); } } } var worker = new CmdService(name, cmd, host, port, args); worker.connect(); } function run() { var baker = require('dsp_shared/lib/baker'); baker.command(service, {args: &quot;args&quot;, opts: &quot;opts&quot;, default: true}); baker.run(); } module.exports = {CmdService: CmdService, run: run}; if (require.main === module) { run(); } × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-11-17T16:42:08-08:00 using the DocStrap template. "},"service_py_cmd.js.html":{"id":"service_py_cmd.js.html","title":"Source: service/py_cmd.js","body":" Dispatchr Backbone Classes BackboneClientBackboneClientMessageBackboneServiceCmdService Source: service/py_cmd.js /** * @fileoverview Utilities to start a command through the python command line service implementation */ var process = require('process'); var spawn = require('child_process').spawn; var _ = require('underscore'); var NODE_PROCESS = 'node'; function start_node_service(service_name, node_file, options, host, port) { options = options || {}; options.argv = options.argv || []; options.argv.unshift(node_file); start_service(service_name, NODE_PROCESS, options, host, port); } function compose_message(options) { var message = []; for(var key in options) { if(options.hasOwnProperty(key)) { message.push(&quot;--&quot;+key); message.push(options[key]); } } return message; } function start_service(service_name, command, options, host, port) { var py_options = ['host', 'port']; var cmd_argv; if(Array.isArray(options)) { py_options = {}; cmd_argv = options; } else { cmd_argv = options.argv || []; var test = compose_message(_.omit(options, py_options.concat('argv'))); cmd_argv.push.apply(cmd_argv, test); py_options = _.pick(options, py_options); } if(host) { py_options.host = host; } if(port) { py_options.port = port; } var py_argv = compose_message(py_options); var full_argv = []; full_argv.push('-u'); full_argv.push('-m'); full_argv.push('backbone.service'); full_argv.push.apply(full_argv, py_argv); full_argv.push(service_name); full_argv.push(command); full_argv.push.apply(full_argv, cmd_argv); // console.log([&quot;python&quot;].concat(full_argv).join(' ')); var child = spawn('python', full_argv); child.stdout.pipe(process.stdout); child.stderr.pipe(process.stderr); } module.exports = { start: start_service, start_node: start_node_service }; if (require.main === module) { var baker = require('dsp_shared/lib/baker'); baker.command(start_service, {default: true, opts: 'options', command: 'start'}); baker.command(start_node_service, {opts: 'options', command: 'start_node'}); baker.run(); } // if (require.main === module) { // var params = process.argv.slice(2); // console.log(&quot;LLLLLLL&quot;, params); // var service_name = params.shift(); // var command = params.shift(); // // // } × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-11-17T16:42:08-08:00 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Dispatchr Backbone Classes BackboneClientBackboneClientMessageBackboneServiceCmdService Classes Classes BackboneClient BackboneClientMessage BackboneService CmdService × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-11-17T16:42:08-08:00 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Dispatchr Backbone Classes BackboneClientBackboneClientMessageBackboneServiceCmdService Dispatchr BackboneDispatchr Backbone message passing utilities Installationon Mac OSX brew install zeromq brew install pkgconfig easy_install pyzmq easy_install baker npm install BrokerBroker is written in Python. It acts as a middle man between the clients and services. It is a standalone process: $ python -m backbone.broker start --help Usage: backbone/broker/__main__.py start [&lt;host&gt;] [&lt;port&gt;] Options: --host [default: 127.0.0.1] --port [default: 5555]example $ python broker/broker.py start --host 127.0.0.1 --port 5555ServiceA service registers itself with the the Broker. Service API libraries exist for Javascript and Python so that Services can be written in either. More Service Docs Here Command ServiceThe command line service exists to allow any command to be easily turned into a service. services$ python -m backbone.service cmd-service --help Usage: /Users/gabriellittman/Development/services/backbone/service/__main__.py cmd-service &lt;name&gt; [&lt;host&gt;] [&lt;port&gt;] [&lt;args&gt;...] Required Arguments: name Options: --host --port Variable arguments: *argsexample services$ python -m backbone.service ls-service ls Create Stream Command Service: ls-service ['ls'] Starting Service: tcp://127.0.0.1:5555 ls-serviceClientA client connects to the broker and allows you make requests to Services. Client API libraries exist for Javascript and Python so that clients can be written in either. More Client Docs Here Commnadl Line RequestThe Command Line Request utility allows you to send easily send requests to services from the command line $ python -m backbone.client request --help Usage: /Users/gabriellittman/Development/services/backbone/client/__main__.py request &lt;name&gt; [&lt;host&gt;] [&lt;port&gt;] [&lt;timeout&gt;] [&lt;args&gt;...] Required Arguments: name Options: --host --port --timeout Variable arguments: *args (specifying a double hyphen (--) in the argument list means all subsequent arguments are treated as bare arguments, not options)Python Example$ python -m backbone.client request ls-service README.md base_attempt client sample util.py __init__.py broker gabe_sample service util.pyc __init__.pyc broker.pyc node_modules test worker.pycNode Example$ node backbone/client request ls-service README.md base_attempt client sample util.py __init__.py broker gabe_sample service util.pyc __init__.pyc broker.pyc node_modules test worker.pyc Index client/client.js This is is a generic broker client api for javascript Source: client/client.js, line 1 Index client/mdc_protocol.js MajorDomo Client Protocol this helper class serializes client messages and replys Source: client/mdc_protocol.js, line 2 Index service/cmd.js Service that takes a command line and arguments and turns it into a service Author: &lt;gabe@dispatchr.co&gt; (Gabriel Littman) Source: service/cmd.js, line 2 Index service/py_cmd.js Utilities to start a command through the python command line service implementation Source: service/py_cmd.js, line 1 Index service/service.js This is is a generic broker woker api for javascript Source: service/service.js, line 2 × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-11-17T16:42:08-08:00 using the DocStrap template. "},"BackboneClient.html":{"id":"BackboneClient.html","title":"Class: BackboneClient","body":" Dispatchr Backbone Classes BackboneClientBackboneClientMessageBackboneServiceCmdService Class: BackboneClient BackboneClient new BackboneClient(host, port) test readme Parameters: Name Type Description host String host to connect to backbone port String port to connect to backbone Source: client/client.js, line 19 Methods connect() Connect to the BackboneClient. Source: client/client.js, line 39 disconnect() Disconnect this conection to the BackboneClient. Source: client/client.js, line 52 getEndpoint() get endpoint url Source: client/client.js, line 25 Returns: The url of the endpoint Type String send(service, port, timeout) Parameters: Name Type Description service String name of service to send message to port String | Array port to connect to backbone timeout Number amount of time in milliseconds to wait for response before giving up Source: client/client.js, line 69 Returns: response promise Type Promise × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-11-17T16:42:09-08:00 using the DocStrap template. "},"BackboneClientMessage.html":{"id":"BackboneClientMessage.html","title":"Class: BackboneClientMessage","body":" Dispatchr Backbone Classes BackboneClientBackboneClientMessageBackboneServiceCmdService Class: BackboneClientMessage BackboneClientMessage new BackboneClientMessage(service, message) Parameters: Name Type Description service String Name of the service message String | Array message to be serialized Source: client/mdc_protocol.js, line 10 Methods getReply() get the reply message Source: client/mdc_protocol.js, line 76 Returns: the reply sent to this message Type Array | String parseReply(raw_reply, options) Parses reply to this message Parameters: Name Type Description raw_reply Array reply gotten from zmq socket options Object Properties Name Type Description simply_short_reply Object If reply has only one item return only the first item. Source: client/mdc_protocol.js, line 38 Returns: reply message with protocol info stripped out Type Array parseResponse() alias to parseReply Source: client/mdc_protocol.js, line 66 serialize() serializes the message to be sent to the Major Domo Broker Source: client/mdc_protocol.js, line 22 Returns: message array to be sent Type Array × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-11-17T16:42:09-08:00 using the DocStrap template. "},"BackboneService.html":{"id":"BackboneService.html","title":"Class: BackboneService","body":" Dispatchr Backbone Classes BackboneClientBackboneClientMessageBackboneServiceCmdService Class: BackboneService BackboneService new BackboneService(service, on_request, options) Parameters: Name Type Description service String name of the service on_request BackboneService~on_request The callback that handles the response. options Object Properties Name Type Description host String host to connect to backbone port String port to connect to backbone Source: service/service.js, line 43 Methods connect() Connect service to backbon Source: service/service.js, line 81 Type Definitions on_request(message, reply) This function is called whenever the service recieves a message. Parameters: Name Type Description message String | Array Message Array reply BackboneService~reply Reply callback Source: service/service.js, line 20 reply(message) This callback is sent with the message as a way to reply to the message Parameters: Name Type Description message String | Array Message Array to be sent as reply to request. Source: service/service.js, line 27 × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-11-17T16:42:09-08:00 using the DocStrap template. "},"CmdService.html":{"id":"CmdService.html","title":"Class: CmdService","body":" Dispatchr Backbone Classes BackboneClientBackboneClientMessageBackboneServiceCmdService Class: CmdService CmdService new CmdService(service, cmd, host, port, options) Parameters: Name Type Description service String name of the service cmd String name of the programe to run host String host name or ip of broker port String port to for service to connect to options Array list or command line options to add to command Source: service/cmd.js, line 20 × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-11-17T16:42:09-08:00 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
